"""Module to offer the function to generate a derivative matrix."""
import numpy as np
from scipy.sparse import lil_matrix

cimport cython
from numpy cimport import_array, ndarray

__all__ = ["compute_dmat"]


import_array()


@cython.boundscheck(False)
@cython.wraparound(False)
@cython.initializedcheck(False)
cpdef object compute_dmat(
    ndarray voxel_map,
    str kernel="laplacian4",
):
    """Generate derivative sparse matrix.

    Parameters
    ----------
    voxel_map : numpy.ndarray
        (N, M) voxel map matrix (negative value must be input into masked voxels)
        If the additional dimension size of the matrix is 1, then it is squeezed to a 2-D matrix.
    kernel : {"x", "y", "laplacian4", "laplacian8"}, optional
        Derivative kernel type. Default is "laplacian8".

    Returns
    -------
    :obj:`scipy.sparse.csc_matrix`
        (N, N) derivative Compressed Sparse Column matrix (if N > M)

    Notes
    -----
    The derivative matrix is generated by the kernel convolution method.
    The kernel is a 3x3 matrix, and the convolution is performed as follows:

    .. math::

        I_{x, y}' = \\sum_{i=-1}^{1}\\sum_{j=-1}^{1} K_{i,j} \\times I_{x + i, y + j},

    where :math:`I_{x, y}` is the 2-D image at the point :math:`(x, y)` and :math:`K_{i,j}` is the
    kernel matrix.
    Using derivative kernel like a laplacian filter, the derivative matrix defined as follows is
    generated:

    .. math::

        \\mathbf{I}' = \\mathbf{K} \\cdot \\mathbf{I},

    where :math:`\\mathbf{I}` is the vecotrized image and :math:`\\mathbf{K}` is the derivative.

    The implemented derivative kernels are as follows:

    - First derivative in x-direction (`kernel="x"`):
      :math:`\\mathbf{K} = \\begin{bmatrix} 0 & 0 & 0 \\\\ -1 & 0 & 1 \\\\ 0 & 0 & 0 \\end{bmatrix}`
    - First derivative in y-direction (`kernel="y"`):
      :math:`\\mathbf{K} = \\begin{bmatrix} 0 & -1 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 1 & 0 \\end{bmatrix}`
    - Laplacian-4 (`kernel="laplacian4"`):
      :math:`\\mathbf{K} = \\begin{bmatrix} 0 & 1 & 0 \\\\ 1 & -4 & 1 \\\\ 0 & 1 & 0 \\end{bmatrix}`
    - Laplacian-8 (`kernel="laplacian8"`):
      :math:`\\mathbf{K} = \\begin{bmatrix} 1 & 1 & 1 \\\\ 1 & -8 & 1 \\\\ 1 & 1 & 1 \\end{bmatrix}`


    Examples
    --------
    .. prompt:: python >>> auto

        >>> from raysect.optical import World
        >>> from cherab.phix.plasma import import_equilibrium
        >>> from cherab.phix.tools.raytransfer import import_phix_rtc
        >>> from cherab.phix.tools import compute_dmat
        >>>
        >>> world = World()
        >>> eq = import_equilibrium()
        >>> rtc = import_phix_rtc(world, equilibrium=eq)
        >>>
        >>> laplacian = compute_dmat(rtc.voxel_map)
        >>> laplacian.toarray()
        array([[-8,  1,  0, ...,  0,  0,  0],
               [ 1, -8,  1, ...,  0,  0,  0],
               [ 0,  1, -8, ...,  0,  0,  0],
               ...,
               [ 0,  0,  0, ..., -8,  1,  0],
               [ 0,  0,  0, ...,  1, -8,  1],
               [ 0,  0,  0, ...,  0,  1, -8]], dtype=int32)
    """
    cdef:
        int i, j, x, y, row, col, map_mat_max
        int[3][3] kernel_array
        ndarray map_matrix
        object dmatrix
        int[:, ::] map_matrix_mv

    # define derivative kernel
    if kernel == "x":
        kernel_array[0][:] = [0, 0, 0]
        kernel_array[1][:] = [-1, 0, 1]
        kernel_array[2][:] = [0, 0, 0]

    elif kernel == "y":
        kernel_array[0][:] = [0, -1, 0]
        kernel_array[1][:] = [0, 0, 0]
        kernel_array[2][:] = [0, 1, 0]

    elif kernel == "laplacian4":
        kernel_array[0][:] = [0, 1, 0]
        kernel_array[1][:] = [1, -4, 1]
        kernel_array[2][:] = [0, 1, 0]

    elif kernel == "laplacian8":
        kernel_array[0][:] = [1, 1, 1]
        kernel_array[1][:] = [1, -8, 1]
        kernel_array[2][:] = [1, 1, 1]

    else:
        raise ValueError("kernel must be 'x', 'y', 'laplacian4' or 'laplacian8'")

    # padding voxel map boundary by -1
    map_matrix = np.pad(np.squeeze(voxel_map), pad_width=1, constant_values=-1)
    map_mat_max = map_matrix.max()

    # define derivative matrix as a sparse matrix
    dmatrix = lil_matrix((map_mat_max + 1, map_mat_max + 1), dtype=np.int32)

    # define memoryview
    map_matrix_mv = map_matrix

    # generate derivative matrix
    for row in range(map_mat_max + 1):
        (x,), (y,) = np.where(map_matrix == row)  # TODO: replace to cythonic codes
        for i in range(-1, 1 + 1):
            for j in range(-1, 1 + 1):
                col = map_matrix_mv[x + i, y + j]
                if col > -1:
                    dmatrix[row, col] = kernel_array[i + 1][j + 1]
                else:
                    pass

    return dmatrix.tocsc()
